<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="MoverList" Id="{6a6492c3-5dac-4c49-8708-8eab34cf4a1d}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK MoverList EXTENDS Objective IMPLEMENTS iMoverList
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Methods" Id="{f0610894-1931-4d0e-a817-1d1b4c8212b1}" />
    <Folder Name="Properties" Id="{3fdda14a-1516-48f6-a734-917962304085}" />
    <Method Name="GetMoverByLocation" Id="{fef36da4-65e6-4a0c-848b-af8a54f15050}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD GetMoverByLocation : REFERENCE to Mover
VAR_INPUT
	Index		: USINT;	// 0 is find the first closest mover, 1 is find the second closest mover, 2 is find the third, etc. etc. etc.
	Position	: LREAL;	// Fixed track position from which to search for movers by proximity
	Direction	: Tc2_MC2.MC_Direction;	// Positive = find the most positive mover whose position is less than the Input. Negative = find the most negative mover whose position is greater than the input
END_VAR

VAR
	positionSort	: ARRAY [0..GVL.NUM_MOVERS-1] OF POINTER TO Mover;		// array copied from tracked movers, to be sorted by position
	sortbuffer		: ARRAY [0..GVL.NUM_MOVERS-1] OF POINTER TO Mover;		// temporary array, just to simplify sorting operation
	currentLeast	: POINTER TO Mover;
	ringOffset		: dint;
	leastIDX		: DINT;
	i				: DINT;
	j				: DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[           
// copy tracked movers into temporary array
memcpy( ADR( sortbuffer ), ADR( internalTrackedMovers ), SIZEOF( internalTrackedMovers ));


// sort temp array based on mover position (simple insertion sort)
FOR i := 0 TO SIZEOF( positionSort ) / SIZEOF( positionSort[0] ) - 1 DO

	leastIDX		:= 0;
	currentLeast	:= 0;
	FOR j := 0 TO SIZEOF( sortBuffer ) / SIZEOF( sortBuffer[0] ) - 1 DO
		IF currentLeast = 0 THEN
			currentLeast		:= sortbuffer[j];
			leastIDX			:= j;
		ELSIF sortbuffer[j] <> 0 AND_THEN sortbuffer[j]^.AxisReference.NcToPlc.ModuloActPos < currentLeast^.AxisReference.NcToPlc.ModuloActPos THEN
			currentLeast		:= sortbuffer[j];
			leastIDX			:= j;
		END_IF;
	END_FOR

	memcpy( ADR( positionSort[i] ), ADR( currentLeast ), SIZEOF( currentLeast ));
	memset( ADR( sortBuffer[leastIDX] ), 0, SIZEOF( sortBuffer[0] ));
	
END_FOR;


// determine offset where position exists
ringOffset		:= 0;
FOR i := 0 TO SIZEOF( positionSort ) / SIZEOF( positionSort[0] ) - 1 DO
	IF positionSort[i] <> 0 AND_THEN positionSort[i]^.AxisReference.NcToPlc.ModuloActPos < Position THEN
		IF Direction = MC_Positive_Direction THEN
			ringOffset := i - Index;
		ELSIF Direction = MC_Negative_Direction THEN
			ringOffset := i+1 + Index;			
		END_IF
	END_IF
END_FOR

IF ringOffset < 0 THEN
	ringOffset := ringOffset + THIS^.TrackedMoverCount;
ELSIF ringOffset >= THIS^.TrackedMoverCount THEN
	ringOffset := ringOffset - THIS^.TrackedMoverCount;
END_IF

// count off either direction to return the proper mover
IF Index < 0 OR Index >= THIS^.TrackedMoverCount THEN
	GetMoverByLocation		REF= 0;
ELSIF Direction = MC_Positive_Direction AND positionSort[ringOffset] <> 0 THEN
	GetMoverByLocation		REF= positionSort[ringOffset]^;
ELSIF Direction = MC_Negative_Direction AND positionSort[ringOffset] <> 0 THEN
	GetMoverByLocation		REF= positionSort[ringOffset]^;
ELSE
	GetMoverByLocation		REF= 0;
END_IF



]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveAllToPosition" Id="{bd912cae-8475-45f4-9366-6d4e3f45dbfd}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD MoveAllToPosition : iMoverList
VAR_INPUT

	DestinationPosition		: LREAL;		// position on track for all shuttles to move towards	

END_VAR

VAR
	i: ulint;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// For every valid mover in the list, pass it a MoveToPosition command
FOR i := 0 TO SIZEOF( internalTrackedMovers ) / SIZEOF( internalTrackedMovers[i] ) - 1 DO
	
	IF internalTrackedMovers[i] <> 0 THEN
		internalTrackedMovers[i]^.MoveToPosition( DestinationPosition );
	END_IF

END_FOR

MoveAllToPosition		:= THIS^;	// return this, to allow method chaining]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveAllToStation" Id="{7e8649c5-afae-438c-9d7c-0849d9778d85}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD MoveAllToStation : iMoverList
VAR_INPUT
	
	DestinationStation	: REFERENCE TO Station;

END_VAR

VAR
	i : ULINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// For every valid mover in the list, pass it a MoveToStation command
FOR i := 0 TO SIZEOF( internalTrackedMovers ) / SIZEOF( internalTrackedMovers[0] ) - 1 DO
	
	IF internalTrackedMovers[i] <> 0 THEN
		internalTrackedMovers[i]^.MoveToStation( DestinationStation ) ;
	END_IF

END_FOR

MoveAllToStation	:= THIS^;	// allows method chaining]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveAllVelocity" Id="{374fc66e-e454-42d2-84eb-da107ea5cc5b}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD MoveAllVelocity : iMoverList
VAR_INPUT
	
	Velocity		: LREAL;

END_VAR
VAR
	i	: ULINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// For every valid mover in the list, pass it a MoveVelocity command
FOR i := 0 TO SIZEOF( internalTrackedMovers ) / SIZEOF( internalTrackedMovers[i] ) - 1 DO
	
	IF internalTrackedMovers[i] <> 0 THEN
		internalTrackedMovers[i]^.MoveVelocity( Velocity );
	END_IF

END_FOR


MoveAllVelocity		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetAllAcceleration" Id="{e13ce26b-c052-44c4-b781-edc2323e6bd8}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD SetAllAcceleration : iMoverList
VAR_INPUT
	
	Acceleration		: LREAL;

END_VAR

VAR
	i	: ULINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// For every valid mover in the list, set the Acceleration values
FOR i := 0 TO SIZEOF( internalTrackedMovers ) / SIZEOF( internalTrackedMovers[i] ) - 1 DO
	
	IF internalTrackedMovers[i] <> 0 THEN
		internalTrackedMovers[i]^.SetAcceleration( Acceleration );
	END_IF

END_FOR


SetAllAcceleration		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetAllDeceleration" Id="{b4a74589-da0f-40fe-9d74-9df176d68d9e}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD SetAllDeceleration : iMoverList
VAR_INPUT
	
	Deceleration		: LREAL;
	
END_VAR
VAR
	i	: ULINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// For every valid mover in the list, set the Deceleration values
FOR i := 0 TO SIZEOF( internalTrackedMovers ) / SIZEOF( internalTrackedMovers[i] ) - 1 DO
	
	IF internalTrackedMovers[i] <> 0 THEN
		internalTrackedMovers[i]^.SetDeceleration( Deceleration );
	END_IF

END_FOR


SetAllDeceleration		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetAllDirection" Id="{61dc841d-816d-4126-817b-0edc70c354b4}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD SetAllDirection : iMoverList
VAR_INPUT
	
	Direction		: Tc3_Mc3Definitions.MC_DIRECTION;
	
END_VAR
VAR
	i	: ULINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// For every valid mover in the list, update the internal Direction parameter
FOR i := 0 TO SIZEOF( internalTrackedMovers ) / SIZEOF( internalTrackedMovers[i] ) - 1 DO
	
	IF internalTrackedMovers[i] <> 0 THEN
		internalTrackedMovers[i]^.SetDirection( Direction );
	END_IF

END_FOR


SetAllDirection		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetAllJerk" Id="{713a2faa-4d72-4826-b835-2931c44827b9}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD SetAllJerk : iMoverList
VAR_INPUT
	
	Jerk			: LREAL;

END_VAR
VAR
	i	: ULINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// For every valid mover in the list, update the internal Jerk Parameter
FOR i := 0 TO SIZEOF( internalTrackedMovers ) / SIZEOF( internalTrackedMovers[i] ) - 1 DO
	
	IF internalTrackedMovers[i] <> 0 THEN
		internalTrackedMovers[i]^.SetJerk( Jerk );
	END_IF

END_FOR


SetAllJerk		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetAllVelocity" Id="{cee9569c-3982-4955-90f1-8e5baf09c135}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD SetAllVelocity : iMoverList
VAR_INPUT
	
	Velocity	: LREAL;	

END_VAR
VAR
	i	: ULINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// For every valid mover in the list, set the Velocity values
FOR i := 0 TO SIZEOF( internalTrackedMovers ) / SIZEOF( internalTrackedMovers[i] ) - 1 DO
	
	IF internalTrackedMovers[i] <> 0 THEN
		internalTrackedMovers[i]^.SetVelocity( Velocity );
	END_IF

END_FOR


SetAllVelocity		:= THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="UnregisterAll" Id="{9f7a3d8e-3975-4fa4-8579-c54f77146104}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD UnregisterAll : BOOL
VAR_INPUT
END_VAR
VAR
	i	: ulint;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[

FOR i := 0 TO SIZEOF( internalTrackedMovers ) / SIZEOF( internalTrackedMovers[i] ) - 1 DO
	IF internalTrackedMovers[i] <> 0 THEN
		THIS^.UnregisterMover( internalTrackedMovers[i]^ );
	END_IF
END_FOR


//UnregisterAll		:= THIS^;	// dunno how you would method chain from this call, but there ya go

// Nope!]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="MoverList">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="MoverList.GetMoverByLocation">
      <LineId Id="45" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="141" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="139" Count="0" />
      <LineId Id="93" Count="1" />
      <LineId Id="140" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="136" Count="1" />
      <LineId Id="102" Count="1" />
      <LineId Id="98" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="113" Count="0" />
      <LineId Id="106" Count="1" />
      <LineId Id="121" Count="0" />
      <LineId Id="111" Count="0" />
      <LineId Id="122" Count="2" />
      <LineId Id="114" Count="0" />
      <LineId Id="108" Count="0" />
      <LineId Id="126" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="127" Count="0" />
      <LineId Id="129" Count="1" />
      <LineId Id="128" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="142" Count="1" />
      <LineId Id="59" Count="0" />
      <LineId Id="117" Count="0" />
      <LineId Id="115" Count="0" />
      <LineId Id="118" Count="0" />
      <LineId Id="134" Count="1" />
      <LineId Id="116" Count="0" />
      <LineId Id="131" Count="2" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="MoverList.MoveAllToPosition">
      <LineId Id="20" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="14" Count="2" />
      <LineId Id="13" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="31" Count="0" />
    </LineIds>
    <LineIds Name="MoverList.MoveAllToStation">
      <LineId Id="9" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="19" Count="1" />
      <LineId Id="16" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="30" Count="0" />
    </LineIds>
    <LineIds Name="MoverList.MoveAllVelocity">
      <LineId Id="12" Count="7" />
      <LineId Id="5" Count="0" />
      <LineId Id="30" Count="1" />
      <LineId Id="29" Count="0" />
    </LineIds>
    <LineIds Name="MoverList.SetAllAcceleration">
      <LineId Id="9" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="13" Count="1" />
      <LineId Id="17" Count="2" />
      <LineId Id="16" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="30" Count="1" />
      <LineId Id="29" Count="0" />
    </LineIds>
    <LineIds Name="MoverList.SetAllDeceleration">
      <LineId Id="11" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="12" Count="1" />
      <LineId Id="16" Count="2" />
      <LineId Id="15" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="27" Count="0" />
    </LineIds>
    <LineIds Name="MoverList.SetAllDirection">
      <LineId Id="17" Count="7" />
      <LineId Id="5" Count="0" />
      <LineId Id="35" Count="1" />
      <LineId Id="34" Count="0" />
    </LineIds>
    <LineIds Name="MoverList.SetAllJerk">
      <LineId Id="13" Count="7" />
      <LineId Id="5" Count="0" />
      <LineId Id="30" Count="1" />
      <LineId Id="29" Count="0" />
    </LineIds>
    <LineIds Name="MoverList.SetAllVelocity">
      <LineId Id="11" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="12" Count="1" />
      <LineId Id="16" Count="2" />
      <LineId Id="15" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="27" Count="0" />
    </LineIds>
    <LineIds Name="MoverList.UnregisterAll">
      <LineId Id="9" Count="1" />
      <LineId Id="6" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="23" Count="1" />
      <LineId Id="22" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="30" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>